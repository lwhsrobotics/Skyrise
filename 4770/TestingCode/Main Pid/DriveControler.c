//#pragma config(Motor,  port1,           backLeft,      tmotorVex393, openLoop)
//#pragma config(Motor,  port2,           frontRight,    tmotorVex393, openLoop, reversed)
//#pragma config(Motor,  port3,           backRight,     tmotorVex393, openLoop, reversed)
//#pragma config(Motor,  port10,          frontLeft,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//clear Encoders
void ClearEncoders(){
	//If Encoder is not Back then it is front
	SensorValue[in3] = 0;
	SensorValue[in4] = 0;
	SensorValue[in5] = 0;
	SensorValue[in6] = 0;
}
int NotOver(int Val) {
	if(Val > 127) {
		return 127;
}
else if(Val < -127) {
	return -127;
}
else {
return Val;
}
}
/*
int RampMax(int ToRamp) {
while(ToRamp > 5 || ToRamp < -5) {
	if(ToRamp > 5) {
	int Go = 100;
	if(Go < 127) {
Go += 10;
}
	return NotOver(Go);
}
else if(ToRamp < -5) {
	int Go = -100;
	if(Go > -127) {
Go -= 10;
}
	return NotOver(Go);
}
else {
return ToRamp;
}
}
return NotOver(ToRamp);
}
*/
int MaxOut(int M) {
	if(M >50) {
		return 120;
}
else if(M < -50) {
	return -120;
}
else {
return M;
}
}

void drive(bool i) {
	if(!i) {
		//bMotorReflected[port10] = true;
	bMotorReflected[port1] = true;
	bMotorReflected[port3] = true;
	motor[port2] = MaxOut(vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4]); //back left
	motor[port3] = MaxOut(vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4]); //front left
	motor[port10] = MaxOut(vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4]);  //back right
	motor[port1] = MaxOut(vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4]); //front right
}
else if(i) {
	//bMotorReflected[port10] = true;
	bMotorReflected[port1] = true;
	bMotorReflected[port3] = true;
	//motor[port2] = -MaxOut(vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4]); //back left
	//motor[port3] = -MaxOut(vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4]); //front left
	//motor[port10] = -MaxOut(vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4]);  //back right
	//motor[port1] = -MaxOut(vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4]); //front right
}
else {
	//bMotorReflected[port10] = true;
	bMotorReflected[port1] = true;
	bMotorReflected[port3] = true;
	motor[port2] = MaxOut(vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4]); //back left
	motor[port3] = MaxOut(vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4]); //front left
	motor[port10] = MaxOut(vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4]);  //back right
	motor[port1] = MaxOut(vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4]); //front right
}
}

//Drive
void driveForward(int dist){
	motor[port2] = 127;
	motor[port3] = 127;
	motor[port10] = 127;
	motor[port1] = 127;
	wait1Msec(dist*100);
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port10] = 0;
	motor[port1] = 0;
}
void driveBackward(int dist){
	motor[port2] = -127;
	motor[port3] = -127;
	motor[port10] = -127;
	motor[port1] = -127;
	wait1Msec(dist*100);
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port10] = 0;
	motor[port1] = 0;
}
void driveLeft(int dist){

}
void driveRight(int dist){

}

void turnRight(int Amt) {
	motor[port2] = 127;
	motor[port3] = 127;
	motor[port10] = -127;
	motor[port1] = -127;
	wait1Msec(Amt*100);
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port10] = 0;
	motor[port1] = 0;
}
